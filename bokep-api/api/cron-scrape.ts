import type { VercelRequest, VercelResponse } from '@vercel/node';
import axios from 'axios';
import * as cheerio from 'cheerio';

// Configuration
const CONFIG = {
    baseUrl: 'https://mcdowellforcongress.com',
    category: 'bokep-indo',
    maxPages: 30,
    githubRepo: 'pharaohanjay-gif/dado-stream',
    githubBranch: 'master',
    outputPath: 'bokep-api/videos.json',
    notifyEmail: 'pharaohanjay.gif@gmail.com',  // Email untuk notifikasi
    websiteName: 'Dado Stream Bioskop'
};

interface Video {
    id: string;
    slug: string;
    title: string;
    poster: string;
    duration: string;
    url: string;
    categories: string[];
    sources: { name: string; url: string }[];
    createdAt: string;
}

interface ScrapeResult {
    success: boolean;
    videosScraped: number;
    newVideosAdded: number;
    totalVideos: number;
    error?: string;
}

// Send email notification using Resend API
async function sendEmailNotification(result: ScrapeResult): Promise<void> {
    const RESEND_API_KEY = process.env.RESEND_API_KEY;
    
    if (!RESEND_API_KEY) {
        console.log('RESEND_API_KEY not set, skipping email notification');
        return;
    }

    const timestamp = new Date().toLocaleString('id-ID', { 
        timeZone: 'Asia/Jakarta',
        dateStyle: 'full',
        timeStyle: 'long'
    });

    const statusEmoji = result.success ? '‚úÖ' : '‚ùå';
    const statusText = result.success ? 'BERHASIL' : 'GAGAL';

    const htmlContent = `
    <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto; padding: 20px;">
        <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 20px; border-radius: 10px 10px 0 0;">
            <h1 style="margin: 0;">${statusEmoji} Auto-Scraper Report</h1>
            <p style="margin: 5px 0 0 0; opacity: 0.9;">${CONFIG.websiteName}</p>
        </div>
        
        <div style="background: #f8f9fa; padding: 20px; border: 1px solid #e9ecef;">
            <h2 style="color: ${result.success ? '#28a745' : '#dc3545'}; margin-top: 0;">
                Status: ${statusText}
            </h2>
            
            <table style="width: 100%; border-collapse: collapse;">
                <tr style="border-bottom: 1px solid #dee2e6;">
                    <td style="padding: 12px 0; color: #6c757d;">üìÖ Waktu</td>
                    <td style="padding: 12px 0; font-weight: bold;">${timestamp}</td>
                </tr>
                <tr style="border-bottom: 1px solid #dee2e6;">
                    <td style="padding: 12px 0; color: #6c757d;">üîç Video Di-scrape</td>
                    <td style="padding: 12px 0; font-weight: bold;">${result.videosScraped} video</td>
                </tr>
                <tr style="border-bottom: 1px solid #dee2e6;">
                    <td style="padding: 12px 0; color: #6c757d;">üÜï Video Baru</td>
                    <td style="padding: 12px 0; font-weight: bold; color: ${result.newVideosAdded > 0 ? '#28a745' : '#6c757d'};">
                        +${result.newVideosAdded} video baru
                    </td>
                </tr>
                <tr style="border-bottom: 1px solid #dee2e6;">
                    <td style="padding: 12px 0; color: #6c757d;">üìä Total Video</td>
                    <td style="padding: 12px 0; font-weight: bold; font-size: 18px; color: #667eea;">
                        ${result.totalVideos} video
                    </td>
                </tr>
                ${result.error ? `
                <tr>
                    <td style="padding: 12px 0; color: #dc3545;">‚ö†Ô∏è Error</td>
                    <td style="padding: 12px 0; color: #dc3545;">${result.error}</td>
                </tr>
                ` : ''}
            </table>
        </div>
        
        <div style="background: #343a40; color: white; padding: 15px; border-radius: 0 0 10px 10px; text-align: center;">
            <p style="margin: 0; font-size: 12px; opacity: 0.8;">
                Auto-generated by Vercel Cron ‚Ä¢ Dado Stream Bioskop
            </p>
        </div>
    </div>
    `;

    try {
        await axios.post('https://api.resend.com/emails', {
            from: 'Dado Stream <onboarding@resend.dev>',
            to: CONFIG.notifyEmail,
            subject: `${statusEmoji} Scraper Report: +${result.newVideosAdded} video baru (Total: ${result.totalVideos})`,
            html: htmlContent
        }, {
            headers: {
                'Authorization': `Bearer ${RESEND_API_KEY}`,
                'Content-Type': 'application/json'
            }
        });
        console.log('Email notification sent successfully');
    } catch (error: any) {
        console.error('Failed to send email:', error.response?.data || error.message);
    }
}

async function sleep(ms: number) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

async function fetchPage(url: string): Promise<string | null> {
    try {
        const response = await axios.get(url, {
            headers: {
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
            },
            timeout: 15000
        });
        return response.data;
    } catch (error: any) {
        console.error(`Error fetching ${url}:`, error.message);
        return null;
    }
}

async function scrapeVideos(): Promise<Video[]> {
    const videos: Video[] = [];
    let page = 1;

    console.log(`Scraping category: ${CONFIG.category}`);

    while (page <= CONFIG.maxPages) {
        const url = page === 1 
            ? `${CONFIG.baseUrl}/category/${CONFIG.category}/`
            : `${CONFIG.baseUrl}/category/${CONFIG.category}/page/${page}/`;
        
        console.log(`Page ${page}: ${url}`);
        
        const html = await fetchPage(url);
        if (!html) break;

        const $ = cheerio.load(html);
        let foundOnPage = 0;

        // Parse video items - try multiple selectors
        $('article, .video-item, .post, .entry').each((i, el) => {
            const $el = $(el);
            const link = $el.find('a').first().attr('href');
            const title = $el.find('.title, h2, h3, .entry-title').first().text().trim() || 
                         $el.find('a').first().attr('title') || 
                         $el.find('img').attr('alt') || '';
            const poster = $el.find('img').first().attr('src') || 
                          $el.find('img').first().attr('data-src') || '';
            const duration = $el.find('.duration, .time').first().text().trim() || '';

            if (link && title && title.length > 3) {
                const slug = link.split('/').filter(Boolean).pop() || `video-${Date.now()}-${i}`;
                videos.push({
                    id: `${Date.now()}-${videos.length}`,
                    slug,
                    title: title.slice(0, 200),
                    poster,
                    duration,
                    url: link.startsWith('http') ? link : `${CONFIG.baseUrl}${link}`,
                    categories: [CONFIG.category],
                    sources: [{
                        name: 'Server 1',
                        url: link.startsWith('http') ? link : `${CONFIG.baseUrl}${link}`
                    }],
                    createdAt: new Date().toISOString()
                });
                foundOnPage++;
            }
        });

        console.log(`Found ${foundOnPage} videos on page ${page}`);

        if (foundOnPage === 0) break;
        
        page++;
        await sleep(500);
    }

    return videos;
}

async function updateGitHub(newVideos: Video[]): Promise<{ success: boolean; totalVideos: number; newCount: number }> {
    const GITHUB_TOKEN = process.env.GITHUB_TOKEN;
    
    if (!GITHUB_TOKEN) {
        console.error('GITHUB_TOKEN not set!');
        return { success: false, totalVideos: 0, newCount: 0 };
    }

    try {
        const apiBase = `https://api.github.com/repos/${CONFIG.githubRepo}/contents/${CONFIG.outputPath}`;
        const rawUrl = `https://raw.githubusercontent.com/${CONFIG.githubRepo}/${CONFIG.githubBranch}/${CONFIG.outputPath}`;
        
        // Get current file SHA (small request)
        let sha: string | undefined;
        let existingVideos: Video[] = [];
        let fetchError = false;
        
        try {
            // First, get SHA from API (small response, just metadata)
            const metaResponse = await axios.get(apiBase, {
                headers: {
                    'Authorization': `token ${GITHUB_TOKEN}`,
                    'Accept': 'application/vnd.github.v3+json'
                },
                timeout: 10000
            });
            sha = metaResponse.data.sha;
            console.log(`Got SHA: ${sha?.substring(0, 7)}...`);
            
            // Then fetch content from raw URL (no size limit)
            const rawResponse = await axios.get(rawUrl, {
                timeout: 30000,
                headers: { 'Cache-Control': 'no-cache' }
            });
            existingVideos = rawResponse.data;
            console.log(`Existing videos: ${existingVideos.length}`);
        } catch (e: any) {
            if (e.response?.status === 404) {
                console.log('No existing file, will create new');
            } else {
                console.error('Error fetching existing videos:', e.message);
                fetchError = true;
            }
        }

        // SAFETY: If we failed to fetch existing and there should be a file, abort!
        if (fetchError) {
            console.error('ABORT: Cannot fetch existing videos, refusing to overwrite');
            return { success: false, totalVideos: 0, newCount: 0 };
        }

        // SAFETY: If we have new videos but existing is suspiciously empty, abort!
        if (newVideos.length > 0 && existingVideos.length === 0 && sha) {
            console.error('ABORT: Existing file has SHA but parsed as empty - possible error');
            return { success: false, totalVideos: 0, newCount: 0 };
        }

        // Merge: keep unique by slug, new videos at the beginning
        const existingSlugs = new Set(existingVideos.map(v => v.slug));
        let newCount = 0;
        
        // Find truly new videos (not in existing)
        const trulyNewVideos: Video[] = [];
        for (const video of newVideos) {
            if (!existingSlugs.has(video.slug)) {
                trulyNewVideos.push(video);
                newCount++;
            }
        }
        
        // Merge: new videos FIRST, then existing (for chronological order)
        const mergedVideos = [...trulyNewVideos, ...existingVideos];
        console.log(`Merged total: ${mergedVideos.length}, New videos: ${newCount}`);

        // Prepare content
        const content = Buffer.from(JSON.stringify(mergedVideos, null, 2)).toString('base64');
        
        // Update or create file
        await axios.put(apiBase, {
            message: `chore(scrape): +${newCount} new videos (total: ${mergedVideos.length})`,
            content,
            sha,
            branch: CONFIG.githubBranch
        }, {
            headers: {
                'Authorization': `token ${GITHUB_TOKEN}`,
                'Accept': 'application/vnd.github.v3+json'
            }
        });

        console.log('GitHub updated successfully!');
        return { success: true, totalVideos: mergedVideos.length, newCount };
    } catch (error: any) {
        console.error('GitHub update failed:', error.response?.data?.message || error.message);
        return { success: false, totalVideos: 0, newCount: 0 };
    }
}

export default async function handler(req: VercelRequest, res: VercelResponse) {
    // Verify cron secret or allow manual trigger
    const authHeader = req.headers.authorization;
    const cronSecret = process.env.CRON_SECRET;
    
    if (cronSecret && authHeader !== `Bearer ${cronSecret}`) {
        // Allow without auth for testing, but log it
        console.log('Warning: No auth header, proceeding anyway...');
    }

    console.log('üöÄ Cron scraper started:', new Date().toISOString());

    try {
        // Scrape videos
        const videos = await scrapeVideos();
        console.log(`Total videos scraped: ${videos.length}`);

        if (videos.length === 0) {
            // Get current total from GitHub for the notification
            let currentTotal = 0;
            try {
                const statsRes = await axios.get(`https://api.github.com/repos/${CONFIG.githubRepo}/contents/${CONFIG.outputPath}`, {
                    headers: { 'Accept': 'application/vnd.github.v3.raw' }
                });
                currentTotal = statsRes.data?.length || 0;
            } catch (e) { /* ignore */ }

            const noVideoResult: ScrapeResult = {
                success: false,
                videosScraped: 0,
                newVideosAdded: 0,
                totalVideos: currentTotal,
                error: 'Situs sumber tidak bisa diakses atau tidak ada video ditemukan'
            };
            await sendEmailNotification(noVideoResult);

            return res.status(200).json({ 
                success: false, 
                message: 'No videos found (source site may be down)',
                totalVideos: currentTotal,
                emailSent: true,
                timestamp: new Date().toISOString()
            });
        }

        // Remove duplicates from scraped
        const uniqueVideos = Array.from(
            new Map(videos.map(v => [v.slug, v])).values()
        );

        // Update GitHub (merge with existing)
        const result = await updateGitHub(uniqueVideos);

        // Prepare scrape result for notification
        const scrapeResult: ScrapeResult = {
            success: result.success,
            videosScraped: uniqueVideos.length,
            newVideosAdded: result.newCount,
            totalVideos: result.totalVideos
        };

        // Send email notification
        await sendEmailNotification(scrapeResult);

        return res.status(200).json({
            ...scrapeResult,
            emailSent: true,
            timestamp: new Date().toISOString()
        });
    } catch (error: any) {
        console.error('Cron error:', error);
        
        // Send failure notification
        const failResult: ScrapeResult = {
            success: false,
            videosScraped: 0,
            newVideosAdded: 0,
            totalVideos: 0,
            error: error.message
        };
        await sendEmailNotification(failResult);

        return res.status(500).json({ 
            success: false, 
            error: error.message,
            emailSent: true
        });
    }
}
